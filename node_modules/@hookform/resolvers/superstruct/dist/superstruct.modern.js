import{transformToNestObject as o,appendErrors as e}from"react-hook-form";import{convertArrayToPathName as t}from"@hookform/resolvers";function r(){return(r=Object.assign||function(o){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(o[r]=t[r])}return o}).apply(this,arguments)}class n extends TypeError{constructor(o,e){let t;const{message:r,...n}=o,{path:s}=o;super(0===s.length?r:"At path: "+s.join(".")+" -- "+r),Object.assign(this,n),this.name=this.constructor.name,this.failures=()=>{var r;return null!=(r=t)?r:t=[o,...e()]}}}function*s(o,e,t={}){const{path:r=[],branch:n=[o],coerce:c=!1}=t,i={path:r,branch:n};c&&(o=e.coercer(o,i));let a=!0;for(const t of e.validator(o,i))a=!1,yield[t,void 0];if(a)for(const t of e.refiner(o,i))a=!1,yield[t,void 0];for(let[t,l,u]of e.entries(o,i)){const e=s(l,u,{path:void 0===t?r:[...r,t],branch:void 0===t?n:[...n,l],coerce:c});for(const r of e)r[0]?(a=!1,yield[r[0],void 0]):c&&(l=r[1],void 0===t?o=l:o instanceof Map?o.set(t,l):o instanceof Set?o.add(l):"object"==typeof(f=o)&&null!=f&&(o[t]=l))}var f;a&&(yield[void 0,o])}function c(o,e,t={}){const r=s(o,e,t),c=function(o){const{done:e,value:t}=o.next();return e?void 0:t}(r);return c[0]?[new n(c[0],function*(){for(const o of r)o[0]&&(yield o[0])}),void 0]:[void 0,c[1]]}const i=(o,n)=>o.failures().reduce((o,{path:s,message:c="",type:i})=>{const a=t(s);return r({},o,s?o[a]&&n?{[a]:e(a,n,o,i||"",c)}:{[a]:o[a]||r({message:c,type:i},n?{types:{[i||""]:c||!0}}:{})}:{})},{}),a=(e,t)=>(r,n,s=!1)=>{const[a,f]=c(r,e,t);return null!=a?{values:{},errors:o(i(a,s))}:{values:f,errors:{}}};export{a as superstructResolver};
//# sourceMappingURL=superstruct.modern.js.map
