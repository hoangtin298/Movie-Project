{"version":3,"file":"zod.js","sources":["../src/zod.ts"],"sourcesContent":["import {\n  appendErrors,\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  transformToNestObject,\n} from 'react-hook-form';\nimport * as z from 'zod';\nimport { ParseParams } from 'zod/lib/src/parser';\nimport { convertArrayToPathName } from '@hookform/resolvers';\n\nconst parseErrorSchema = (\n  zodError: z.ZodError,\n  validateAllFieldCriteria: boolean,\n) => {\n  if (zodError.isEmpty) {\n    return {};\n  }\n\n  const errors = [...zodError.errors];\n  let previous: Record<string, any> = {};\n\n  for (const error of errors) {\n    const { path, message, code: type } = error;\n    const currentPath = convertArrayToPathName(path);\n\n    if ('unionErrors' in error) {\n      for (const subErrors of error.unionErrors.map((e) => e.errors)) {\n        errors.push(...subErrors);\n      }\n    }\n\n    previous = {\n      ...previous,\n      ...(path\n        ? previous[currentPath] && validateAllFieldCriteria\n          ? {\n              [currentPath]: appendErrors(\n                currentPath,\n                validateAllFieldCriteria,\n                previous,\n                type,\n                message,\n              ),\n            }\n          : {\n              [currentPath]: previous[currentPath] || {\n                message,\n                type,\n                ...(validateAllFieldCriteria\n                  ? {\n                      types: { [type]: message || true },\n                    }\n                  : {}),\n              },\n            }\n        : {}),\n    };\n  }\n\n  return previous;\n};\n\nexport const zodResolver = <T extends z.ZodSchema<any, any>>(\n  schema: T,\n  options?: ParseParams,\n): Resolver<z.infer<T>> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  const result = schema.safeParse(values, options);\n\n  if (result.success) {\n    return { values: result.data, errors: {} } as ResolverSuccess<z.infer<T>>;\n  }\n\n  return {\n    values: {},\n    errors: transformToNestObject(\n      parseErrorSchema(result.error, validateAllFieldCriteria),\n    ),\n  } as ResolverError<z.infer<T>>;\n};\n"],"names":["parseErrorSchema","zodError","validateAllFieldCriteria","isEmpty","errors","previous","error","path","message","type","code","currentPath","convertArrayToPathName","unionErrors","map","e","push","appendErrors","types","schema","options","values","_","result","safeParse","success","data","transformToNestObject"],"mappings":"skCAWA,IAAMA,EAAmB,SACvBC,EACAC,GAEA,GAAID,EAASE,QACX,MAAO,GAMT,IAHA,MAAMC,YAAaH,EAASG,QACxBC,EAAgC,OAEhBD,kBAAQ,WAAjBE,UACDC,EAA8BD,EAA9BC,KAAMC,EAAwBF,EAAxBE,QAAeC,EAASH,EAAfI,KACjBC,EAAcC,yBAAuBL,GAE3C,GAAI,gBAAiBD,EACnB,cAAwBA,EAAMO,YAAYC,IAAI,SAACC,UAAMA,EAAEX,yBACrDA,EAAOY,WAAPZ,WAIJC,OACKA,EACCE,EACAF,EAASM,IAAgBT,UAEpBS,GAAcM,eACbN,EACAT,EACAG,EACAI,EACAD,cAIDG,GAAcN,EAASM,OACtBH,QAAAA,EACAC,KAAAA,GACIP,EACA,CACEgB,cAAUT,GAAOD,IAAW,MAE9B,OAGV,IAIR,OAAOH,uBAGkB,SACzBc,EACAC,mBAEAC,EACAC,EACApB,YAAAA,IAAAA,GAA2B,OAE3B,IAAMqB,EAASJ,EAAOK,UAAUH,EAAQD,GAExC,uBAAIG,EAAOE,QACF,CAAEJ,OAAQE,EAAOG,KAAMtB,OAAQ,IAGjC,CACLiB,OAAQ,GACRjB,OAAQuB,wBACN3B,EAAiBuB,EAAOjB,MAAOJ,MAjBV"}