{"version":3,"file":"zod.modern.js","sources":["../src/zod.ts"],"sourcesContent":["import {\n  appendErrors,\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  transformToNestObject,\n} from 'react-hook-form';\nimport * as z from 'zod';\nimport { ParseParams } from 'zod/lib/src/parser';\nimport { convertArrayToPathName } from '@hookform/resolvers';\n\nconst parseErrorSchema = (\n  zodError: z.ZodError,\n  validateAllFieldCriteria: boolean,\n) => {\n  if (zodError.isEmpty) {\n    return {};\n  }\n\n  const errors = [...zodError.errors];\n  let previous: Record<string, any> = {};\n\n  for (const error of errors) {\n    const { path, message, code: type } = error;\n    const currentPath = convertArrayToPathName(path);\n\n    if ('unionErrors' in error) {\n      for (const subErrors of error.unionErrors.map((e) => e.errors)) {\n        errors.push(...subErrors);\n      }\n    }\n\n    previous = {\n      ...previous,\n      ...(path\n        ? previous[currentPath] && validateAllFieldCriteria\n          ? {\n              [currentPath]: appendErrors(\n                currentPath,\n                validateAllFieldCriteria,\n                previous,\n                type,\n                message,\n              ),\n            }\n          : {\n              [currentPath]: previous[currentPath] || {\n                message,\n                type,\n                ...(validateAllFieldCriteria\n                  ? {\n                      types: { [type]: message || true },\n                    }\n                  : {}),\n              },\n            }\n        : {}),\n    };\n  }\n\n  return previous;\n};\n\nexport const zodResolver = <T extends z.ZodSchema<any, any>>(\n  schema: T,\n  options?: ParseParams,\n): Resolver<z.infer<T>> => async (\n  values,\n  _,\n  validateAllFieldCriteria = false,\n) => {\n  const result = schema.safeParse(values, options);\n\n  if (result.success) {\n    return { values: result.data, errors: {} } as ResolverSuccess<z.infer<T>>;\n  }\n\n  return {\n    values: {},\n    errors: transformToNestObject(\n      parseErrorSchema(result.error, validateAllFieldCriteria),\n    ),\n  } as ResolverError<z.infer<T>>;\n};\n"],"names":["parseErrorSchema","zodError","validateAllFieldCriteria","isEmpty","errors","previous","error","path","message","code","type","currentPath","convertArrayToPathName","subErrors","unionErrors","map","e","push","[object Object]","appendErrors","types","zodResolver","schema","options","async","values","_","result","safeParse","success","data","transformToNestObject"],"mappings":"sVAWA,MAAMA,EAAmB,CACvBC,EACAC,KAEA,GAAID,EAASE,QACX,MAAO,GAGT,MAAMC,EAAS,IAAIH,EAASG,QAC5B,IAAIC,EAAgC,GAEpC,IAAK,MAAMC,KAASF,EAAQ,CAC1B,MAAMG,KAAEA,EAAFC,QAAQA,EAASC,KAAMC,GAASJ,EAChCK,EAAcC,EAAuBL,GAE3C,GAAI,gBAAiBD,EACnB,IAAK,MAAMO,KAAaP,EAAMQ,YAAYC,IAAKC,GAAMA,EAAEZ,QACrDA,EAAOa,QAAQJ,GAInBR,OACKA,EACCE,EACAF,EAASM,IAAgBT,EACvB,CACEgB,CAACP,GAAcQ,EACbR,EACAT,EACAG,EACAK,EACAF,IAGJ,CACEU,CAACP,GAAcN,EAASM,OACtBH,QAAAA,EACAE,KAAAA,GACIR,EACA,CACEkB,MAAO,CAAEF,CAACR,GAAOF,IAAW,IAE9B,KAGV,IAIR,OAAOH,GAGIgB,EAAc,CACzBC,EACAC,IACyBC,MACzBC,EACAC,EACAxB,GAA2B,KAE3B,MAAMyB,EAASL,EAAOM,UAAUH,EAAQF,GAExC,OAAII,EAAOE,QACF,CAAEJ,OAAQE,EAAOG,KAAM1B,OAAQ,IAGjC,CACLqB,OAAQ,GACRrB,OAAQ2B,EACN/B,EAAiB2B,EAAOrB,MAAOJ"}