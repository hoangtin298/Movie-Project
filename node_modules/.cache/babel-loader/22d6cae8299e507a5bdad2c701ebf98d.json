{"ast":null,"code":"import { transformToNestObject as e } from \"react-hook-form\";\n\nfunction r() {\n  return (r = Object.assign || function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = arguments[r];\n\n      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n    }\n\n    return e;\n  }).apply(this, arguments);\n}\n\nvar t = function (t, n) {\n  return void 0 === n && (n = {\n    abortEarly: !1\n  }), function (o, a, s) {\n    void 0 === s && (s = !1);\n\n    try {\n      return Promise.resolve(function (e, s) {\n        try {\n          var c = (n.context && \"development\" === process.env.NODE_ENV && console.warn(\"You should not used the yup options context. Please, use the 'useForm' context object instead\"), Promise.resolve(t.validate(o, r({}, n, {\n            context: a\n          }))).then(function (e) {\n            return {\n              values: e,\n              errors: {}\n            };\n          }));\n        } catch (e) {\n          return s(e);\n        }\n\n        return c && c.then ? c.then(void 0, s) : c;\n      }(0, function (t) {\n        var n = function (e, t) {\n          var n;\n          return Array.isArray(e.inner) && e.inner.length ? e.inner.reduce(function (e, n) {\n            var o,\n                a,\n                s = n.path,\n                c = n.message,\n                u = n.type,\n                i = e[s] && e[s].types || {},\n                p = s || u;\n            return r({}, e, p ? ((a = {})[p] = r({}, e[p] || {\n              message: c,\n              type: u\n            }, t ? {\n              types: r({}, i, (o = {}, o[u] = i[u] ? [].concat([].concat(i[u]), [c]) : c, o))\n            } : {}), a) : {});\n          }, {}) : ((n = {})[e.path] = {\n            message: e.message,\n            type: e.type\n          }, n);\n        }(t, s);\n\n        return {\n          values: {},\n          errors: e(n)\n        };\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n};\n\nexport { t as yupResolver };","map":{"version":3,"sources":["../src/yup.ts"],"names":["error","validateAllFieldCriteria","Array","isArray","inner","length","reduce","previous","path","message","type","previousTypes","types","key","concat","yupResolver","schema","options","abortEarly","values","context","process","env","NODE_ENV","console","warn","validate","errors","e","parsedErrors","parseErrorSchema","transformToNestObject"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { Resolver, transformToNestObject, FieldValues } from 'react-hook-form';\nimport Yup from 'yup';\nimport Lazy from 'yup/lib/Lazy';\n\n/**\n * From 0.32.0, Yup add TypeScript support and `path` typing is optional that's why we have `@ts-expect-error`\n * FYI: `path`: a string, indicating where there error was thrown. `path` is empty at the root level.\n * react-hook-form's values are object so path is defined\n * https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n */\nconst parseErrorSchema = (\n  error: Yup.ValidationError,\n  validateAllFieldCriteria: boolean,\n) => {\n  return Array.isArray(error.inner) && error.inner.length\n    ? error.inner.reduce(\n        (previous: Record<string, any>, { path, message, type }) => {\n          // @ts-expect-error\n          const previousTypes = (previous[path] && previous[path].types) || {};\n          const key = path || type;\n\n          return {\n            ...previous,\n            ...(key\n              ? {\n                  [key]: {\n                    ...(previous[key] || {\n                      message,\n                      type,\n                    }),\n                    ...(validateAllFieldCriteria\n                      ? {\n                          types: {\n                            ...previousTypes,\n                            // @ts-expect-error\n                            [type]: previousTypes[type]\n                              ? // @ts-expect-error\n                                [...[].concat(previousTypes[type]), message]\n                              : message,\n                          },\n                        }\n                      : {}),\n                  },\n                }\n              : {}),\n          };\n        },\n        {},\n      )\n    : {\n        // @ts-expect-error\n        [error.path]: { message: error.message, type: error.type },\n      };\n};\n\ntype ValidateOptions<T extends Yup.AnyObjectSchema> = Parameters<\n  T['validate']\n>[1];\n\nexport const yupResolver = <TFieldValues extends FieldValues>(\n  schema: Yup.AnyObjectSchema | Lazy<any, any>,\n  options: ValidateOptions<Yup.AnyObjectSchema> = {\n    abortEarly: false,\n  },\n): Resolver<TFieldValues> => async (\n  values,\n  context,\n  validateAllFieldCriteria = false,\n) => {\n  try {\n    if (options.context && process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"You should not used the yup options context. Please, use the 'useForm' context object instead\",\n      );\n    }\n    return {\n      values: await schema.validate(values, {\n        ...options,\n        context,\n      }),\n      errors: {},\n    };\n  } catch (e) {\n    const parsedErrors = parseErrorSchema(e, validateAllFieldCriteria);\n    return {\n      values: {},\n      errors: transformToNestObject(parsedErrors),\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}